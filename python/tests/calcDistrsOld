    """def __calcInputDistrMatrix(self):"""
        """
        if self.excPointMatrix is a column vector there is only one distribution, possibly acting on multiple strings
        if the column vector contains more than 1 nonzero elms and hence J is a column vector else if
        self.excPointMatrix is a matrix there are n different excitations, where n is the nr. of columns in
        self.excPointMatrix, hence loop over cols in the matrix and for every different distribution source append
        a new column vector of appropriate size to J
        """
        """k = self.__class__.k; colSize = 2*np.sum(self.Nt)
        if isinstance(self.excPointMatrix,np.ndarray):
            mat_trans = self.excPointMatrix.T; rowSize = mat_trans.shape[0]; J = lil_matrix((colSize,rowSize))
            for col,i in zip(mat_trans,xrange(rowSize)):
                inds = np.nonzero(col)[0]; pts = col[col > 0]
                for ind,pt in zip(inds,pts):
                    if ind == 0:
                        h = self.mechObjs[0].h; b1 = self.mechObjs[0].b1
                        J[:self.Nt[0],i] = spdistr(k**2/(h*(1 + b1*k)),pt,self.mechObjs[0].N,'lin')
                    elif ind == len(self.mechObjs) - 1:
                        h = self.mechObjs[-1].h; b1 = self.mechObjs[-1].b1
                        J[-2*self.Nt[-1]:-self.Nt[-1],i] = spdistr(k**2/(h*(1 + b1*k)),pt,self.mechObjs[-1].N,'lin')
                    else:
                        h = self.mechObjs[ind].h; b1 = self.mechObjs[ind].b1
                        stInd = 2*np.sum(self.Nt[:ind]); endInd = 2*np.sum(self.Nt[:ind + 1])
                        endInd = stInd + (endInd - stInd)/2
                        J[stInd:endInd,i] = spdistr(k**2/(h*(1 + b1*k)),pt,self.mechObjs[ind].N,'lin')
        else:
            mat_trans = zip(*self.excPointMatrix); rowSize = len(mat_trans); J = lil_matrix((colSize,rowSize))
            for col,i in zip(mat_trans,xrange(rowSize)):
                inds,pts = zip(*[(ind,pt) for ind,pt in zip(xrange(len(col)),col) if pt > 0])
                for ind,pt in zip(inds,pts):
                    if ind == 0:
                        h = self.mechObjs[0].h; b1 = self.mechObjs[0].b1
                        J[:self.Nt[0],i] = spdistr(k**2/(h*(1 + b1*k)),pt,self.mechObjs[0].N,'bilin').tolil().T\
                            .reshape((self.mechObjs[0].Np1,1)) if self.__iscoll(pt) else\
                            spdistr(k**2/(h*(1 + b1*k)),pt,self.mechObjs[0].N,'lin')
                    elif ind == len(self.mechObjs) - 1:
                        h = self.mechObjs[-1].h; b1 = self.mechObjs[-1].b1
                        J[-2*self.Nt[-1]:-self.Nt[-1],i] = spdistr(k**2/(h*(1 + b1*k)),pt,self.mechObjs[-1].N,'bilin').tolil().T\
                            .reshape((self.mechObjs[-1].Np1,1)) if self.__iscoll(pt) else\
                            spdistr(k**2/(h*(1 + b1*k)),pt,self.mechObjs[-1].N,'lin')
                    else:
                        h = self.mechObjs[ind].h; b1 = self.mechObjs[ind].b1
                        stInd = 2*np.sum(self.Nt[:ind]); endInd = 2*np.sum(self.Nt[:ind + 1])
                        endInd = stInd + (endInd - stInd)/2
                        J[stInd:endInd,i] = spdistr(k**2/(h*(1 + b1*k)),pt,self.mechObjs[ind].N,'bilin').tolil().T\
                            .reshape((self.mechObjs[ind].Np1,1)) if self.__iscoll(pt) else\
                            spdistr(k**2/(h*(1 + b1*k)),pt,self.mechObjs[ind].N,'lin')
        return J"""

    """def __calcOutputDistrMatrix(self):"""
        """
        if self.readoutPointMatrix is a column vector there is only one output channel else if self.readoutPointMatrix
        is a matrix there are n different output channels, where n is the nr. of columns in self.readoutPointMatrix,
        hence loop over cols in the matrix and for every output channel append a new column vector of appropriate size
        to J
        """
        """k = self.__class__.k; colSize = 2*np.sum(self.Nt)
        if isinstance(self.readoutPointMatrix,np.ndarray):
            mat_trans = self.readoutPointMatrix.T; rowSize = mat_trans.shape[0]; J = lil_matrix((colSize,rowSize))
            for col,i in zip(mat_trans,xrange(rowSize)):
                inds = np.nonzero(col)[0]; pts = col[col > 0]
                for ind,pt in zip(inds,pts):
                    if ind == 0:
                        h = self.mechObjs[0].h
                        J[:2*self.Nt[0],i] = vstack((spdistr(1/(k*h),pt,self.mechObjs[0].N,'lin'),\
                                                     -spdistr(1/(k*h),pt,self.mechObjs[0].N,'lin')))
                    elif ind == len(self.mechObjs) - 1:
                        h = self.mechObjs[-1].h
                        J[-2*self.Nt[-1]:,i] = vstack((spdistr(1/(k*h),pt,self.mechObjs[-1].N,'lin'),\
                                                       -spdistr(1/(k*h),pt,self.mechObjs[-1].N,'lin')))
                    else:
                        h = self.mechObjs[ind].h
                        stInd = 2*np.sum(self.Nt[:ind]); endInd = 2*np.sum(self.Nt[:ind+1])
                        endInd = stInd + (endInd - stInd)
                        J[stInd:endInd,i] = vstack((spdistr(1/(k*h),pt,self.mechObjs[ind].N,'lin'),\
                                                    -spdistr(1/(k*h),pt,self.mechObjs[ind].N,'lin')))
        else:
            mat_trans = zip(*self.readoutPointMatrix); rowSize = len(mat_trans); J = lil_matrix((colSize,rowSize))
            for col,i in zip(mat_trans,xrange(rowSize)):
                inds,pts = zip(*[(ind,pt) for ind,pt in zip(xrange(len(col)),col) if pt > 0])
                for ind,pt in zip(inds,pts):
                    if ind == 0:
                        h = self.mechObjs[0].h
                        distr = spdistr(1/(k*h),pt,self.mechObjs[0].N,'bilin').tolil().T.reshape((self.mechObjs[0].Np1,1)) if\
                            self.__iscoll(pt) else spdistr(1/(k*h),pt,self.mechObjs[0].N,'lin')
                        J[:2*self.Nt[0],i] = vstack((distr,-distr))
                    elif ind == len(self.mechObjs) - 1:
                        h = self.mechObjs[-1].h
                        distr = spdistr(1/(k*h),pt,self.mechObjs[-1].N,'bilin').tolil().T.reshape((self.mechObjs[-1].Np1,1)) if\
                            self.__iscoll(pt) else spdistr(1/(k*h),pt,self.mechObjs[-1].N,'lin')
                        J[-2*self.Nt[-1]:,i] = vstack((distr,-distr))
                    else:
                        h = self.mechObjs[ind].h
                        stInd = 2*np.sum(self.Nt[:ind]); endInd = 2*np.sum(self.Nt[:ind+1])
                        endInd = stInd + (endInd - stInd)
                        distr = spdistr(1/(k*h),pt,self.mechObjs[ind].N,'bilin').tolil().T.reshape((self.mechObjs[ind].Np1,1)) if\
                            self.__iscoll(pt) else spdistr(1/(k*h),pt,self.mechObjs[ind].N,'lin')
                        J[stInd:endInd,i] = vstack((distr,-distr))
                        
        return J"""

            """
            if self.excPointMatrix is a column vector there is only one distribution, possibly acting on multiple strings
            if the column vector contains more than 1 nonzero elms and hence J is a column vector else if
            self.excPointMatrix is a matrix there are n different excitations, where n is the nr. of columns in
            self.excPointMatrix, hence loop over cols in the matrix and for every different distribution source append
            a new column vector of appropriate size to J
            """

        """
        if self.readoutPointMatrix is a column vector there is only one output channel else if self.readoutPointMatrix
        is a matrix there are n different output channels, where n is the nr. of columns in self.readoutPointMatrix,
        hence loop over cols in the matrix and for every output channel append a new column vector of appropriate size
        to J
        """
